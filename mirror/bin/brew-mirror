#!/usr/bin/env brew ruby
# frozen_string_literal: true

# dump_formulae: given a Homebrew installation, dumps a JSON
# representation of all available packages.

require "optparse"
require "json"
require "securerandom"

# We need Homebrew's libraries.
abort "Make sure to run me via `brew ruby`!" unless Object.const_defined? :Homebrew

MirrorResource = Struct.new(:fetchable, :identifier, :downloader, :url)

# These are the simplest to support, and cover 99.9% of formulae.
# Notable exception: clang-format, which is in a SVN repo.
BREW_OFFLINE_DOWNLOAD_STRATEGIES = [
  CurlDownloadStrategy,
  CurlApacheMirrorDownloadStrategy,
  NoUnzipCurlDownloadStrategy,
  # NOTE: These don't have a stable checksum, so we fabricate an identifier for them.
  # See `sensible_identifier`.
  GitDownloadStrategy,
  GitHubGitDownloadStrategy,
]

BREW_OFFLINE_DIR = File.expand_path "~/.offlinebrew"

Dir.mkdir BREW_OFFLINE_DIR unless Dir.exist?(BREW_OFFLINE_DIR)

BREW_OFFLINE_CONFIG = File.join BREW_OFFLINE_DIR, "config.json"
BREW_OFFLINE_URLMAP = File.join BREW_OFFLINE_DIR, "urlmap.json"

# Given a fetchable, produce a sensible and probably unique identifier.
def sensible_identifier(ds, checksum = nil)
  case ds
  when GitDownloadStrategy, GitHubGitDownloadStrategy
    # Git/GitHub resources don't have checksums and Homebrew doesn't make it easy
    # to retrieve their revision/last commit hash, so we just create a unique
    # identifier for them.
    SecureRandom.uuid
  else
    checksum.to_s
  end
end

options = {
  directory: "/Users/william/mnt/nessie/brew-mirror",
  baseurl: "http://localhost:8000",
  sleep: 0.5,
  config_only: false,
}

OptionParser.new do |parser|
  parser.banner = "Usage: brew ruby brew-mirror [options]"

  parser.on "-d", "--directory DIRECTORY" do |d|
    options[:directory] = d
  end

  parser.on "-s", "--sleep SECS", Float, "sleep between each formula download" do |s|
    options[:sleep] = s
  end

  parser.on "-c", "--config-only", "write configuration files but don't perform the mirror" do
    options[:config_only] = true
  end
end.parse!

unless Dir.exist?(options[:directory])
  abort "Fatal: the output directory must exist"
end

# Dump the homebrew-core commit we're dumping at, the timestamp,
# and the path of our cache to the directory that brew-offline reads.
ohai "Writing brew-offline config..."

config = {}

commit = begin
  core_dir = File.join HOMEBREW_LIBRARY, "Taps/homebrew/homebrew-core"
  Dir.chdir core_dir do
    `git rev-parse HEAD`.chomp
  end
end

config[:commit] = commit
config[:stamp] = Time.now.to_i.to_s
config[:cache] = options[:directory]
config[:baseurl] = options[:baseurl]

File.write(BREW_OFFLINE_CONFIG, config.to_json)

exit if options[:config_only]

urlmap = {}

# Finally, fetch the (stable) resources for each formula in homebrew-core.
Formula.each do |formula|
  # Skip formulae that aren't in the core tap.
  next unless formula.tap.core_tap?

  ohai "Collecting resources for #{formula.name}..."

  # Build up a list of MirrorResources for the formula.
  resources = []

  resources << MirrorResource.new(formula.stable,
                                  sensible_identifier(formula.stable.downloader,
                                                      formula.stable.checksum),
                                  formula.stable.downloader,
                                  formula.stable.url)

  formula.stable.resources.each do |_name, res|
    resources << MirrorResource.new(res,
                                    sensible_identifier(res.downloader, res.checksum),
                                    res.downloader,
                                    res.url)
  end

  formula.stable.patches.select(&:external?).each do |patch|
    resources << MirrorResource.new(patch,
                                    sensible_identifier(patch.resource.downloader,
                                                        patch.resource.checksum),
                                    patch.resource.downloader,
                                    patch.url)
  end

  # Make sure every resource in the formula is retrievable via one of the
  # download strategies supported by our mirror, skipping (and logging) the formula
  # if one or more isn't.
  bad_resources = resources.select do |res|
    !BREW_OFFLINE_DOWNLOAD_STRATEGIES.include? (res.downloader.class)
  end

  if bad_resources.any?
    bad_resources.each do |res|
      opoo "#{formula.name} has an unmirrorable resource: #{res.url} (#{res.downloader.class})"
    end
    next
  end

  ohai "Downloading resources for #{formula.name}..."

  resources.each do |res|
    # We'll do the logging here.
    res.downloader.shutup!

    old_location = res.downloader.cached_location
    new_location = Pathname.new(File.join(options[:directory], "#{res.identifier}#{old_location.extname}"))

    res.downloader.fetch unless new_location.exist?

    if new_location.exist?
      ohai "Already migrated!"
    else
      FileUtils.mv res.downloader.cached_location.to_s, new_location.to_s
      ohai "\t#{res.downloader.cached_location} -> #{new_location}"
    end

    # Add to the urlmap regardless.
    urlmap[res.url] = new_location.basename
  end

  sleep options[:sleep]
end

File.write(BREW_OFFLINE_URLMAP, urlmap.to_json)
